转载请注明链接：https://blog.csdn.net/feather_wch/article/details/80021699

#CoordinatorLayout、AppbarLayout和CollapsingToolbarLayout
版本：2018/4/21-1

##CoordinatorLayout

1、导入包：
```xml
compile 'com.android.support:design:28.0.0-alpha1'
```

2、CoordinatorLayout的作用
>1. 加强版`FrameLayout`，适合作为`应用顶层的布局`，提供`交互行为`
>2. 通过给`子View`设定`Behavior`可以实现他们的交互性为。`Behavior`能实现一系列的交互行为和布局变化，包括`侧滑菜单`、`可滑动删除的UI元素`、`View之间`跟随移动。

3、CoordinatorLayout实现两控件联动(隐式关联通过Behavior的layoutDependsOn方法)
>布局: 需要给`观察者`设置`Behavoir`
```xml
<?xml version="1.0" encoding="utf-8"?>
<android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:background="#20b2aa">

        <com.feather.imageview.View.TextPathView
            android:id="@+id/text_path_view"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="NULL"
            android:gravity="center"
            android:textSize="80dp"
            android:textColor="@color/colorAccent"
            android:background="#ffffff"
            app:layout_behavior=".FollowBehavior"/>

        <Button
            android:id="@+id/path_btn"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Button"
            android:textSize="40dp"
            />

</android.support.design.widget.CoordinatorLayout>
```
>自定义`Behavior`
```java
public class FollowBehavior extends CoordinatorLayout.Behavior<TextView>{

    /**
     * 必须要有该构造方法，不然无法通过`XML`构造
     */
    public FollowBehavior(Context context, AttributeSet attributeSet){
        super(context, attributeSet);
    }
    /**
     * 让布局知道布局中的Button就是被观察者
     */
    @Override
    public boolean layoutDependsOn(CoordinatorLayout parent, TextView child, View dependency) {
        return dependency instanceof Button;
    }

    /**
     * 2. 被观察者发生变化后，回调该方法。可以改变两者的属性.
     */
    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, TextView child, View dependency) {
        child.setX(dependency.getX());
        child.setY(dependency.getY() + dependency.getHeight() + 10);
        return true;
    }
}
```

4、CoordinatorLayout的Behavior原理
>1. `CoordinatorLayout`将主要`交互行为的处理`交给`Behavior`处理。
>2. `观察者(绑定Behavior)`的`测量、布局`会被`Behavior拦截`
>3. `被观察者`的`Touch事件、嵌套滚动`会被`Behavior拦截`

5、Behavior如何拦截`Touch事件`
>1. `CoordinatorLayout`会`重写onInterceptTouchEvent`方法，让`绑定了Behavior`的子View会先执行`Behavior`的`OnInterceptTouchEvent`。如果`返回true`则交给`Behavior处理Touch事件`，否则还是`子View`原先的处理逻辑。

6、Behavior如何拦截`测量、布局`
>1. `CoordinatorLayout`的`onMeasure`中会执行`behavior`的`onMeasureChild方法`，如果`返回true`则由`Behavior`接管测量过程。
>2. `onLayout`中也是交由`Behavior`接管`布局过程`。

7、View关联的两种方法
>1. `隐式关联`: `为child绑定Behavior`，并在`Bhavior`的`layoutDependsOn()`方法中，如果`dependency`为`被观察者`则返回`返回true`
>2. `显式依赖`：通过` app:layout_anchor=`指定`被观察者ID`，通过`app:layout_anchorGravity=`表明需要的`响应效果`。
```xml
//显式依赖的属性
<com.feather.imageview.View.TextPathView
    xxx
    app:layout_anchor="@+id/path_btn"
    app:layout_anchorGravity="bottom"/>
```

##AppBarLayout
8、AppBarLayout是什么
>1. `垂直的LinearLayout`实现了`Material Design`中`App bar`的`Scrolling Gesture特性`
>2. `AppBarLayout`的`子View`需要声明`滚动行为`，通过`layout_scrollFlags属性`或者`setScrollFlags()方法`指定。
>3. `AppBarLayout`必须要作为`CoordinatorLayout`的直接`子View`
>4. `CoordinatorLayout`中必须要提供可滚动的View`Scrolling View`.
>5. `AppBarLayout`和`Scrolling View`的关联，需要通过将`Scrolling View`的`Behavior`设置为`AppBarLayout.ScrollingViewBehavior`来建立。

9、`app:layout_scrollFlags`的具体参数
>备注：使用`ScrollView`是无效的，原因不明。`RecyclerView`是有效的。
|参数|作用|
|---|---|
|scroll|表明`View`和`Scrolling View`是一体的，必须要有|
|enterAlways|标题栏跟随者`Scrolling View`同时出现。|
|exitUntilCollapsed|先滚动该`View`,达到最小高度后，开始滚动`Scrolling View`。`该View`折叠后，`Scrolling View`滚动到最上方完全出现后，才开始滚动`该View`|
|enterAlwaysCollapsed|View和手指向下滑动，先`Scrolling View`顶部完全出现后，`标题栏`才会出现|
|snap|“观察者-标题栏”要么完全出现，要么完全为0|
