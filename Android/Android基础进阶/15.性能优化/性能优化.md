#Android性能优化
版本: 2018/3/19-1

##布局优化
1、布局优化的思想
>1. 减少布局文件层级
>2. 使用高性能布局

2、View是什么？
> 1. View是Android系统在屏幕上的视觉呈现.
> 2. View是一种控件

3、View是怎么绘制出来的？
>1. View的绘制流程是从ViewRoot的performTraversals（）方法开始
>2. measure()
>3. layout()
>3. draw()

4、View是怎么呈现在界面上的？
>1. Android中的视图都是通过Window来呈现的(Activity、Dialog还是Toast都有一个Window)
>2. 然后通过WindowManager来管理View。
>3. Window和顶级View——DecorView的通信是依赖ViewRoot完成的。

5、View和ViewGroup什么区别？
>1. View是所有控件和布局的父类。
>2. `ViewGroup`也属于`View`，构成一种树状结构

6、RelativeLayout和LinearLayout的性能差异
>1. 两者`layout和draw`性能相等，区别在于`measure`过程
>2. `RelativeLayout`对所有`子View`会进行`两次measure(横向+纵向)`---因为`子View`间可能同时有`纵向和横向的依赖关系`，所有都需要进行一次测量。
>3. `LinearLayout`会进行`一次measure`，如果有`weight属性`才会进行`第二次measure`

7、布局的选择
>1. 如果不涉及到`层级深度`，应该选择`高效的LinearLayout或者FrameLayout`
>2. 涉及到层级深度时，如`ListView`中更适合使用`RelativeLayout`，且尽可能使用`pading`代替`margin`
>3. `ConstraintLayout`是性能最好的布局！

8、布局优化的三种方法
>1. `include`标签
>2. `merge`标签
>3. `ViewStub`

9、include标签的特点和使用方法
>1. `include`主要是用于布局重用，就不需要重复写相同的布局
>2. `include`中只支持`layout_`开头的属性，如果指定了`id`则会覆盖掉`所包含的布局文件根元素的id属性`
```xml
//main.xml
<android.support.constraint.ConstraintLayout ...>
    <include
        android:id="@+id/include"
        layout="@layout/my_include_layout"
        android:layout_width="200dp"
        android:layout_height="200dp"
        .../>
    <TextView
        android:id="@+id/sample_text"
        ... />
</android.support.constraint.ConstraintLayout>

//my_include_layout.xml
<android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/sample_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        .../>

</android.support.constraint.ConstraintLayout>
```

10、merge标签的作用
>1. `merge`一般配合`include标签`使用，用于减少`布局层级`
>2. 假如`include标签`外层是`LinearLayout`，内部布局根元素的布局也是`LinearLayout` ，使用`merge`能减少不必要的层级。
```xml
//需要将include所包含的内部布局的根布局使用merge标签，如my_include_layout.xml
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <TextView
        android:id="@+id/sample_text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="I'm include"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</merge>
```

11、ViewStub的作用和使用
>1. 轻量级组件(继承View)：不可视、大小为0
>2. `ViewStub`一旦进行显示，就不存在了，取而代之的是被inflate的布局，并将ID设置为ViewStub中`android：inflateid`属性所指的ID，因此两次调用`inflate`方法会报错
>3. `ViewStub`还不支持`merge标签`
```xml
<ViewStub
 android:id="@+id/not_often_use"
 ......
 android:layout="@layout/not_often_use"/>
```
```java
//1. 获得ViewStub组件
mViewStub = (ViewStub)findViewById(R.id.not_often_use); //viewstub的ID
//2-1. 显示该View的第一种方法
mViewStub.setVisibility(View.VISIBLE)
//2-2. 显示该View的第二种方法
View flateView = mViewStub.inflate();
TextView textview = (TextView)inflateView.findViewById(R.id.tv);
```

12、绘制优化-优化View的onDraw方法
>1. `onDraw`中不要创建新的`局部对象`---`onDraw`可能会频繁调用，瞬间创建大量对象和大量GC
>2. `onDraw`中不要做耗时的任务，尽量要保证`View的绘制频率60fps(每帧画面不超过16ms)`

13、内存泄漏优化
>1. `静态变量`所导致的内存泄漏：如Activity内部静态变量持有Activity的this等
>2.  `单例模式`导致的内存泄漏：单例模式的对象中的链表等持有了`如：Activity的this指针`，却没有即使释放会导致泄露，因为单例的特点是其生命周期和`Applicaiton`一致。
>3. `属性动画`不停止会导致内存泄漏：无限循环动画会持有`Activity的View`，而`View`持有了`Activity`，最终导致泄露。解决办法是在`onDestory`中调用`animator.cancel()`

14、ANR是什么？
>1. UI线程执行耗时操作会导致ANR
>2. 如果`BroadcastReceiver`10秒没有执行完操作，就会导致ANR



##参考资料
1. [Android性能优化《Android群英传》第十章](http://blog.csdn.net/feather_wch/article/details/52652395)
1. [RelativeLayout和LinearLayout的性能对比](http://blog.csdn.net/guyuealian/article/details/52162774)
