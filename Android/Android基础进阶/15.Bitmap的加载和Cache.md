>主要包括三个部分：
>1. Bitmap的高效加载
>2. Bitmap的缓存
>3. ListeView等列表的优化

#Bitmap的加载和Cache
版本: 2018/3/6-2

##Bitmap的高效加载

1、Bitmap在Android中是什么？
>指一张图片，可以是`png`或者`jpg`等常见的图片格式

2、Android中加载图片的四种方法
|BitmapFactory提供的四类方法|作用|备注|
|---|---|---|
|decodeFile()|从`文件系统`加载Bitmap对象|间接调用`decodeStream`|
|decodeResource()|从`资源`加载Bitmap对象|间接调用`decodeStream`|
|decodeStream()|从`输入流`加载Bitmap对象||
|decodeByteArray()|从`字节数组`加载Bitmap对象||
>四类方法最终在`Android底层`实现，对应`BitmapFactory`类的几个`native`方法。

3、如何高效加载Bitmap？
>1. 利用`BitmapFactory.Options`能通过一定`采样率`来加载缩小后的图片，并在`ImageView`中显示
>2. 这样能`降低内存占用`并从一定程度上避免`OOM`

4、BitmapFactory.Options如何使用？
>1. 利用其参数`inSampleSize-采样率`进行缩小
>2. `inSampleSize`的值应该是2的指数，如1、2、4、8、16
>3. `inSampleSize`值为1时，大小为原始大小
>4. `inSampleSize`值为2时，宽高缩小为1/2，因此像素数为1/4

5、如何获取采样率？
>1. 将`BitmapFactory.Options`的`inJustDecodeBounds`参数设置为`true`并加载图片(`inJustDecodeBounds=true`时，只会解析图片原始信息，不会真正加载图片)
>2. 从`BitmapFactory.Options`中取出`图片的原始宽高`，他们对应于`outWidth`和`outHeight`参数
>3. 根据采样率规则并结合目标View所需大小计算出`采样率inSampleSize`
>4. 将`BitmapFactory.Options`的`inJustDecodeBounds`设置为`false`，重新加载图片
>* 四大方法都支持类似的加载方法，但是`decodeStream()`有些特殊
```java
//加载图片
mImageView.setImageBitmap(decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100));

//采用合适采样率进行图片加载
public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight){
    //1. 获取图片原始尺寸
    final BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeResource(res, resId, options);
    //2. 计算出采样率
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
    //3. 用采样率重新加载图片
    options.inJustDecodeBounds = false;
    return BitmapFactory.decodeResource(res, resId, options);
}

public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight){
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;

    if(height > reqHeight || width > reqWidth){
        final int halfHeight = height / 2;
        final int halfWidth = width / 2;
        while((halfHeight / inSampleSize) >= reqHeight && (halfWidth / inSampleSize) >= reqWidth){
            inSampleSize *= 2;
        }
    }

    return inSampleSize;
}
```

##Android中的缓存策略

6、缓存策略的思路？
> 1. 从网络上加载图片时，先从内存中去获取
> 2. 内存中没有时，再从存储设备中获取
> 3. 存储设备也没有时，才从网络上获取

7、缓存策略
> 1. 缓存策略主要包括`缓存的添加、获取和删除`
> 2. 其中特殊的`删除`，主要是当`存储设备`容量满时，需要去删除一些`旧缓存`并添加`新缓存`

8、缓存算法
> 1. 缓存算法决定如何删除哪份缓存
> 2. 常用缓存算法是`LRU(Least Recently Used)`-优先淘汰最近最少使用的`缓存对象`
> 3. `采用LRU的缓存算法`有两种：`LruCache`和`DiskLruCache`
> 4. `LruCache`用于实现`内存缓存`
> 5. `DiskLruCache`用于实现`存储设备缓存`

9、强引用、软引用和弱引用的区别
| 引用 | 介绍 |
|---|---|
| 强引用   | 直接的对象引用   |
| 软引用   | 当一个对象只有软引用时，系统`内存不足`是该对象会被`gc回收`   |
| 弱引用   | 当一个对象只有弱引用时，此对象随时会被`gc回收`   |

10、LruCache的特点和作用
>1. `LruCache`是`Android 3.1`提供的类，低版本中需要使用`support-v4`
> 2. `LruCache`是一个`泛型类`, 它的内部采用一个`LinkedHashMap`以`强引用`的方式存储外界的`缓存对象`
> 3. `LruCache`提供`get()/put()`来完成`缓存`的获取和添加操作
> 4. `LruCache`中缓存满时就会移除较早的`缓存对象`
> 5. `LruCache`是线程安全的

11、LruCache的典型初始化过程
```java
        //1. 获取最大内存数(单位KB)
        int maxMemory = (int)(Runtime.getRuntime().maxMemory() / 1024);

        //2. 总容量：缓存大小为 1/8
        int cacheSize = maxMemory / 8;
        LruCache<String, Bitmap> mMemoryCache = new LruCache<String, Bitmap>(cacheSize){
            @Override
            //3. 计算出缓存对象的大小(`单位`需要与`总容量单位`一致，也应该为KB，所以除以1024)
            protected int sizeOf(String key, Bitmap value) {
                //一行总字节数 x 高度 = 总字节数
                return bitmap.getRowBytes() * bitmap.getHeight() / 1024;
            }
        };

        //4. 获取缓存对象
        mMemoryCache.get(key);

        //5. 存储缓存对象
        mMemoryCache.put(key, bitmap);

        //6. 可以删除指定缓存对象
        mMemoryCache.remove(key);
```

未完待续......
