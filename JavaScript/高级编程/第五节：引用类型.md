1、创建Object类型的实例的方法：
> 1.使用new操作符后跟Object构造函数：
>```
>var person = new Object();
>person.name = "John";
>```
> 2.使用对象字面量表示法(推荐)：
> 1. 左括号"{"表示对象字面量的开始；
> 2. 定义属性，用冒号(属性名也可以用字符串)
>```
>var person = {
>  name : "Joh",
>  age : 12,
>  "id" : "as",    //属性名使用字符串
>  5 : true        //数值属性名会自动转换为字符串
>};
>```
> **注意：使用字面量语法时，留空括号，则表示定义默认属性和方法的对象**
>```
>var person = {};      //与new Object()相同
>```

2、使用字面量语法创建Object类型的优点
> 1.代码少；
> 2.封装数据；
> 3.方便向函数传递大量可选参数
>```
>function displayInfo(args){
>  var output="";
>  if(typeof args.name == "string"){
>    output +="Name: "+args.name+"\n";
>  }
>  if(typeof args.age =="number"){
>    output +="Age: "+args.age+"\n";
>  }
>  alert(output);
>}
>displayInfo({     //传递多个参数
>  name:"Kitty",
>  age:34
>});
>```

3、访问对象属性的方法
> 1.点表示法：
>```
>alert(person.name);
>```
> 2.方括号表示法：将要访问的属性以字符串的形式放在方括号中
>```
>alert(peron["name"]);
>
>var propertyName="name";  //两种方法相同
>alert(propertyName);
>```
> 3.两种表示法的区别：
> 1. 如果属性名中包含了会导致语法错误的字符，或者属性名使用的是关键字或保留字，只可以使用方括号表示法。
> 2. 除非必须使用方括号表示法，一般情况下，建议使用点表示法。

4、Array类型特点：
> 1.数组是数据的有序列表；
> 2.ECMAScript数组的每一项都可以保存任何类型的数据；（第一个位置保存字符串，第二个位置保存数值.....等）
> 3.数组的大小可以动态调整——随着数据的添加自动增长以容纳新数据。

5、创建数组的方式
> 1.使用Array构造函数：可以省略new关键字
> 1. 如果预先知道数组的大小，也可以给构造函数传递数量(length属性);
> 2. 可以向构造函数传递数组中应该包含的项；
>```
>var colors = new Array();
>var colors = Array();        //两种表达相同
>var colors = new Array(20);
>var colors = new Array("red", "green", "blue");
>```
> **注意：**
> > 1.给构造函数传递数值，则会按照数值创建包含给定项数的数组；
> > 2.给构造函数传递其他类型的参数，则会创建包含那个值的只有一项的数组。
>```
>var colors = new Array(2);   //创建一个包含3项的数组
>var names = new Array("hello")   //创建一个包含一项，即字符串"hello"的数组
>```
> 2.使用数组字面量：数组字面量由一对包含数组项的方括号表示，对个数组项之间以逗号隔开。
>```
>var colors = ["red", "blue"];     //创建一个包含2个字符串的数组
>var name = [];          //创建一个空的数组
>var values = [1,3,];    //不建议，会创建一个包含2或3项的数组（与IE浏览器有关）
>```

6、读取数组的值的方法：
> 1.使用方括号并提供相应值的基于0的数字索引；
>```
>var colors = ["red","green","blue"];
>alert(colors[0]);
>colors[2] = "yellow";
>```

7、数组的属性
> 1.length属性——返回对应项的值；
>```
>var colors = ["red","green","bue"];
>var names = [];
>alert(colors.length);  //3
>alert(names.length);   //0
>```
> 2.通过设置length属性，可以从数组的末尾移除项或向数组中添加项；
>```
>>var colors = ["red","green","blue"];
>colors.length = 2;        //移除最后一项
>alert(colors[2]);         //undefined
>```
>```
>var colors = ["red","green","blue"];
>colors.length = 4;          //添加项
>alert(colors[3]);           //undefined
>```
> 3.通过length属性，在数组的末尾添加新项；
>```
>var colors = ["red"];
>colors[colors.length] = "green";
>colors[colors.length] = "blue";
>```

8、检测数组
> 1.instanceof操作符：可以判断某个对象是不是数组（单一的全局执行环境中）；
> 2.但是，instanceof存在问题：
> 1. 如果页面包含多个框架，就会存在多个不同的全局执行环境，从而会有多个不同的Array构造函数；
> 2. 如果从一个框架向另一个框架传入数组，那么传入的数组与第二个框架中的数组就会有不同的构造函数。
> 3. 为了解决这个问题，使用Array.isArray()方法，
> 4. 这个方法目的是确定某个值到底是不是数组。
>```
>if(Array.isArray(value)){
>
>}
>```

9、转换数组的方法
> 1.toLocaleString()：把数组转化为本地数组，返回与toString()相同的值，但不同的是，他会调用每一项的toLocaleString()方法；
> 2.toString()：返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串；
> 3.valueOf()：返回数组。
>```
>var colors = ["red","green","blue"];
>console.log(colors.toString());        //red,green,blue
>console.log(colors.valueOf());         //["red","green","blue"]
>console.log(colors.toLocaleString());  //red,green,blue
>```

10、join()方法
> 1.作用：使用不同的分隔符来构建字符串；
> 2.join方法接收一个参数，即用作分隔符的字符串，然后会返回包含所有数组项的字符串；
> 3.如果不给join方法传递参数，或者传入undefined，数组则使用逗号作为分隔符。
>```
>var colors = ["red","blue","green"];
>alert(colors.join(","));         //red,blue,green
>alert(colors.join("||"));        //red||blue||green
>console.log(colors.join());       //red,blue,green
>console.log(colors.join(undefined));   //red,blue,green
>```

11、找方法
> 1.栈：是一种LIFO(Last-In-First-Out，后进先出)的数据结构；
> 2.ECMAScript位数组提供了push()和pop()方法，实现似栈行为。
> 1. push()方法：可以接收任意数量的参数，逐个添加到数组末尾，并返回修改后数组的长度；
> 2. pop()方法：从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。
>```
>var colors = new Array();
>var count = colors.push("red","blue");
>console.log(count);                        //2
>count = colors.push("green");              
>console.log(colors);                       //["red","blue","green"]
>console.log(colors.length);                //3
>var item = colors.pop();
>console.log(item);                         //green
>console.log(colors.length);                //2
>```

12、队列方法
> 1.访问规则：是FIFO(First-in-First-Out，先进先出)的数据结构；
> 2.使用shift()和push()方法，实现队列。
> 1. shift()：移除数组中的第一项并返回该项，同时，数组的长度减1；
>```
>var colors = new Array();
>var count = colors.push("red","green");
>console.log(count);                         //2
>var item = colors.shift();
>console.log(item);                          //red
>```
> 3.使用unshift()和pop()方法。实现相反的队列(先进后出)；
> 1. unshitf()：在数组的前端添加任意个项并返回新数组的长度。

13、重排序方法
> 1.reverse()：会反转数组项的顺序；
>```
>var values = [1,2,3,4,5];
>alert(values.reverse());                //5,4,3,2,1
>```
> 2.sort()：按升序排列数组项——最小的位于最前面，最大的位于最后面；
> 1. sort()方法会先调用toString()转型方法，比较字符串的大小。
>```
>var values = [0,1,5,10,15];
>alert(values.sort());             //0,1,10,15,5(比较字符串的大小)
>```
> 2. 对于绝大多数的数据类型，可以将比较函数作为sort方法的参数。
>```
>function compare(value1,value2){
>  if(value1<value2){
>    return -1;
>  }else if(value1>value2){
>    return 1;
>  }else{
>    return 0;
>  }
>}
>var values = [0,1,5,10,15];
>alert(values.sort(compare));             //0,1,5,10,15
>```

14、操作方法
> 1.concat()：基于当前数组中的所有项创建一个新的数组；
> 1. 没有给concat传递参数，会复制当前数组并返回副本；
> 2. 传递一个或多个数组，会将这些数组中的每一项都添加到结果数组中；
> 3. 如果传递的不是数组，这些值会被简单地添加到结果数组的末尾。
>```
>var colors = ["red","blue"];
>var color2 = colors.concat("yellow",["green","brown"]);
>alert(color2);            //red,blue,yellow,green,brown
>```
> 2.slice()：基于当前数组的一个或多个项创建一个新的数组，接收一个或两个参数，是要返回项的起始和结束位置。
> 1. 只有一个参数，slice()方法返回从该参数指定位置开始到数组末尾的所有项；
> 2. 有两个参数，返回起始和结束位置之间的项——不包括结束位置的项；
>```
>var colorss = ["red","green","blue","yellow","purple"];
>var color2 = colorss.slice(1);
>var color3 = colorss.slice(1,4);
>console.log(color2);       //["green","blue","yellow","purple"]
>console.log(color3);       //["green","blue","yellow"]
>```
> 3.splice()：向数组的中部插入项；
> 1. 删除：可以删除任意项，需指定2个参数：要删除的第一项的位置和要删除的项数。例：splice(0,2)会删除数组的前两项。
> 2. 插入：向指定位置插入任意数量的项，需提供3个参数：起始位置，0（要删除的项数），要插入的项。
> 3. 替换：向指定位置插入任意数量的项，且同时删除任意数量的项，需指定3个参数：起始位置，要要删除的项数，要插入的任意数量的项。
>```
>var colors = ["red","green","blue"];
>var removed = colors.splice(0,1);       //删除第一项
>alert(removed);                         //red
>
>removed = colors.splice(1,0,"yellow","orange");   //从位置1插入两项
>alert(removed);                        //返回空数组
>
>removed = colors.splice(1,1,"red","purple");     //插入两项，删除一项
>alert(colors);                         //["red","red","purple","blue"]
>alert(removed);                        //green
>```

15、位置方法indexOf()和lastIndexOf()
>- 1.相同：
> 1. 接收两个参数：要查找的项和（可选的）表示查找起点位置的索引；
> 2. 返回要查找的项在数组中的位置，
> 3. 没有找到项的情况下，返回-1；
> 4. 比较参数和数组中的每一项，会使用全等操作符。
> 2.不同：
> 1. indexOf()从数组的开头（位置0）开始向后查找；
> 2. lastIndexOf()从数组的末尾开始向前查找。
>```
>var numbers = [1,2,3,4,5,4,3,2,1];
>alert(numbers.indexOf(4));            //3
>alert(numbers.lastIndexOf(4));        //5
>alert(numbers.indexOf(4,4));            //5
>alert(numbers.lastIndexOf(4,4));        //3
>alert(numbers.indexOf(7));              //-1
>```

16、迭代方法
> 1.every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true；
> 2.filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组；
> 3.forEach()：对数组中的每一项运行给定函数，没有返回值；
> 4.map()：对数组中的每一项给定函数，返回每次函数调用的结果组成的数组；
> 5.some()：对数组的每一项给定函数，如果该函数对任一项返回true，则返回true。
> 6.每个方法都接收两个参数：要在每一项上运行的函数和(可选的)运行该函数的作用域对象——影响this值；
> 7.传入的函数会接收3个参数：数组项的值，该项在数组中的位置，数组对象本身。
>```
>var numbers = [1,2,3,4,5,4,3,2,1];
>var everyReslut = numbers.every(funtion(item,index,array){
>  return (item > 2);
>});                                  //false
>var someResult = numbers.some(funtion(item,index,array){
>  return (item > 2);
>});                                  //true
>var filterResult = numbers.filter(funtion(item,index,array){
>  return (item > 2);
>});                                  //[3,4,5,4,3]
>```

17、缩小方法
> 1.reduce()：从数组的第一项开始，逐个遍历到最后；
> 2.reduceRight()：从数组的最后一项开始，向前遍历到第一项。
> 3.两个方法接收参数：在每一项上调用的函数和（可选的）作为缩小基础的初始值；
> 4.传入的函数接收4个参数：前一个值，当前值，项的索引和数组对象，
> 5.这个函数返回的任何值都会作为第一个参数自动传给下一项。
>```
>var values = [1,2,3,4,5];   //第一次执行时，pre=1，cur=2
>var sum = values.reduce(function(pre,cur,index,array){   //求和
>  return pre + cur;            
>});
>```

18、Date类型
> 1.Date类型使用自UTC(国际协调时间)1970年1月1日午夜(零时)开始经过的毫秒数来保存日期。

19、创建日期对象
> 1.new操作符和构造函数
> 1. 构造函数不传递参数：会自动返回当前日期和时间；
> 2. 传入参数（表示日期的毫秒数）：创建特定日期和时间的对象；
> 3. 为了简化传入的参数，提供了Date.parse()和Date.UTC()方法。

20、Date.parse()和Date.UTC()作用
> 1.Date.parse()：接收一个表示日期的字符串参数，然后根据这个字符串返回相应日期的毫秒数；
> 1. 如果传入的参数不能表示日期，会返回NaN；
> 2. 传入的参数形式跟浏览器接受的日期格式有关。
> 3. 实际，直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.Parse()方法。
>```
>var someDate = new Date(Date.parse("May 25,2018"));
>var someDate = new Date("May 25,2018");           //两个方法等价
>```
> 2.Date.UTC()：
> 1. 返回表示日期的毫秒数，
> 2. 它的参数分别是年份，基于0的月份，月中的哪一天(1-31)，小时数(0-23)，分钟，秒，毫秒数。
> 3. 这些参数中，前两个参数是必须的（年和月）。
>```
>var y2k = new Date(Date.UTC(2000,0));          //GMT时间2000年1月1日午夜零时
>var allFives = new Date(Date.UTC(2005,4,5,17,55,55));     //GMT时间2005年5月5日下午5:55:55
>```
> 4. 实际，Date构造函数也会模仿Date.UTC()，但是，日期和时间都基于本地时区而非GMT创建。
>```
>var y2k = new Date(2000,0);         //本地时间2000年1月1日午夜零时
>```

21、Date.now()作用
> 1.返回表示调用这个方法时的日期和时间的毫秒数；
> 2.在支持Date.now()方法的浏览器中，可以直接使用；
> 3.在不支持Date.now()方法的浏览器中，使用+操作符把Date对象转换成字符串。
>```
>var start = +new Date();     //取得开始时间
>```

22、Date类型继承的方法
> 1.toLocaleString()：按照与浏览器设置的地区项适应的格式返回日期和格式；
> 2.toString()：返回带有时区信息的日期和时间，一般是24小时制表示；
> 3.valueOf()：返回日期的毫秒数，可以使用比较操作符来比较日期。

23、日期格式化方法：因浏览器而异
> 1.toDateString()：以特定于实现的格式显示星期几、月、日和年；
> 2.toTimeString()：以特定于实现的格式显示时、分、秒和时区；
> 3.toLocaleDateString()：以特定于实现的格式显示星期几、月、日和年；
> 4.toUTCString()：以特定于实现的格式显示完整的UTC日期。

24、RegExp类型
> 1.作用：支持正则表达式；

25、用字面量创建正则表达式
> 1.语法：
>```
>var expression = / pattern / flags;
>```
> 2.模式（pattern）：可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用；
> 3.标志（flags）：每个正则表达式都可带有一或多个标志，用以标明正则表达式的行为；
> 1. g：全局(global)模式，模式应用于所有字符串；
> 2. i：不区分大小写(case-insensitive)模式，在确定匹配项时忽略模式与字符串的大小写；
> 3. m：多行(multiline)模式，在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
>```
>var pattern1 = /\.at/gi;         //匹配所有".at"，不区分大小写(转义)
>```
> **注意：模式中使用的所有元字符都必须转义**
>- 元字符：`( [ { \ ^ $ | ) ? * + . ] }`

26、使用RegExp构造函数创建正则表达式
> 1.RegExp构造函数，接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。
>```
>var pattern1 = /[bt]at/i;           //匹配第一个"bat"或"cat"，不区分大小写
>var pattern2 = new RegExp("[bc]at","i");   //两个方法等价
>```
> 2.构造函数接收的参数都是字符串，在某些情况下要进行双重转义
> 1. 所有的元字符都必须双重转义；
> 2. 例如，`\n`：字符`\`在字符串中被转义为`\\`,在正则表达式中就会变成`\\\\`

27、RegExp实例属性
